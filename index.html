<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 코드 터널 데모</title>
    <style>
        /* CSS: 페이지 여백을 없애고 캔버스를 꽉 채웁니다. */
        body {
            margin: 0;
            overflow: hidden; /* 스크롤바 제거 */
            background-color: #000; /* 배경색을 검은색으로 */
        }
        canvas {
            display: block;
        }
        /* CSS: 페이드아웃 효과를 위한 오버레이 */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none; /* 클릭 방지 */
            transition: opacity 1s ease-in-out; /* 부드러운 전환 */
        }
    </style>
</head>
<body>
    <!-- 페이드아웃을 위한 오버레이 -->
    <div id="overlay"></div>

    <!-- 
      JavaScript: ES 모듈(import)을 사용합니다.
      three.js 라이브러리 및 필수 애드온들을 CDN에서 불러옵니다.
    -->
    <script type="module">
        // three.js 코어 라이브러리
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        
        // 3D 텍스트 생성을 위한 로더 및 지오메트리
        import { FontLoader } from 'https://unpkg.com/three/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three/examples/jsm/geometries/TextGeometry.js';
        
        // '네온' 효과(블룸)를 위한 포스트 프로세싱
        import { EffectComposer } from 'https://unpkg.com/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- 전역 변수 설정 ---
        let scene, camera, renderer, composer, bloomPass, tunnel;
        let font; // 로드된 폰트 저장
        const textObjects = []; // 텍스트 객체들
        const tunnelSegments = 100; // 터널의 길이 (세그먼트 수)
        const segmentLength = 2; // 각 세그먼트의 길이
        const tunnelLength = tunnelSegments * segmentLength;
        const cameraSpeed = 0.15;

        // --- 초기화 함수 ---
        function init() {
            // 1. Scene (장면) 설정
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 50); // 안개 효과 (가까울수록 잘 보임)

            // 2. Camera (카메라) 설정
            const fov = 75; // 시야각
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 5; // 카메라 초기 위치

            // 3. Renderer (렌더러) 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 조명 (Light) 설정
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // 은은한 전체 조명
            scene.add(ambientLight);

            // 5. 터널 생성 (TubeGeometry)
            createTunnel();

            // 6. 포스트 프로세싱 (블룸 효과) 설정
            setupPostProcessing();

            // 7. 3D 텍스트 로드 및 생성
            loadFontAndCreateText();
            
            // 8. 창 크기 조절 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
        }

        // --- 터널 생성 함수 ---
        function createTunnel() {
            // 터널의 경로 (직선)
            const path = new THREE.LineCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -tunnelLength) // Z축 방향으로 길게
            );
            
            // 터널 지오메트리
            const geometry = new THREE.TubeGeometry(
                path,          // 경로
                tunnelSegments, // 터널 세그먼트
                3,             // 터널 반지름
                16,            // 원형 세그먼트
                false          // 닫힘 여부
            );
            
            // 터널 재질 (와이어프레임)
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,    // '코드' 느낌의 초록색
                wireframe: true,
                side: THREE.DoubleSide // 터널 안쪽에서도 보이도록 설정
            });
            
            tunnel = new THREE.Mesh(geometry, material);
            scene.add(tunnel);
        }

        // --- 폰트 로드 및 텍스트 생성 함수 ---
        function loadFontAndCreateText() {
            const fontLoader = new FontLoader();
            // three.js 예제 폰트 (JSON) 사용
            fontLoader.load('https://unpkg.com/three/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
                font = loadedFont;
                
                // 텍스트 재질 (밝은 흰색, 블룸 효과를 받음)
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

                // 텍스트 1: Welcome
                createText("Welcome", textMaterial, -20);
                
                // 텍스트 2: 2025 졸업전시
                createText("2025 졸업전시", textMaterial, -50);
                
                // 텍스트 3: CODE의 세계로...
                createText("CODE의 세계로...", textMaterial, -80);
            });
        }

        // --- 텍스트 생성 헬퍼 함수 ---
        function createText(text, material, zPosition) {
            const textGeo = new TextGeometry(text, {
                font: font,
                size: 1.5,
                height: 0.2,
                curveSegments: 12,
            });
            
            // 텍스트를 중앙에 정렬
            textGeo.center(); 
            
            const textMesh = new THREE.Mesh(textGeo, material);
            textMesh.position.z = zPosition;
            
            scene.add(textMesh);
            textObjects.push(textMesh);
        }

        // --- 포스트 프로세싱 (블룸) 설정 함수 ---
        function setupPostProcessing() {
            // 1. RenderPass: 기본 장면을 렌더링
            const renderPass = new RenderPass(scene, camera);

            // 2. UnrealBloomPass: 블룸(빛 번짐) 효과
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength (강도)
                0.4, // radius (반경)
                0.85 // threshold (밝기 임계값, 이 값보다 밝은 부분만 빛남)
            );
            
            // 3. EffectComposer: 패스들을 조합
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }

        // --- 애니메이션 루프 함수 ---
        function animate() {
            requestAnimationFrame(animate); // 매 프레임마다 animate 함수 호출

            // 1. 카메라 이동 (터널 안으로 전진)
            camera.position.z -= cameraSpeed;

            // 2. 텍스트 회전 (선택 사항)
            textObjects.forEach(text => {
                text.rotation.y += 0.005;
            });

            // 3. 터널의 끝에 도달했을 때 처리
            if (camera.position.z < -tunnelLength + 20) {
                // 밝은 빛이 터져나오는 효과 (블룸 강도를 높임)
                bloomPass.strength += 0.05;

                // 화면을 하얗게 덮음 (페이드아웃)
                document.getElementById('overlay').style.opacity = '1';
                
                // (실제 구현 시) 페이드아웃이 완료되면 메인 페이지로 이동
                // setTimeout(() => {
                //     window.location.href = 'YOUR_MAIN_PAGE.html';
                // }, 1000); 
            }
            
            // 4. 렌더링 (composer를 통해 렌더링해야 블룸 효과 적용)
            // renderer.render(scene, camera); // <- 이것 대신
            composer.render(); // <- 이것 사용
        }

        // --- 창 크기 조절 함수 ---
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 카메라 비율 업데이트
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // 렌더러 및 컴포저 크기 업데이트
            renderer.setSize(width, height);
            composer.setSize(width, height);
        }

        // --- 실행 ---
        init();
        animate();

    </script>
</body>
</html>