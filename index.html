<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 코드 터널 데모</title>
    <style>
        /* CSS: 페이지 여백을 없애고 캔버스를 꽉 채웁니다. */
        body {
            margin: 0;
            overflow: hidden; /* 스크롤바 제거 */
            background-color: #000; /* 배경색을 검은색으로 */
        }
        canvas {
            display: block;
        }
        /* CSS: 페이드아웃 효과를 위한 오버레이 */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none; /* 클릭 방지 */
            transition: opacity 1s ease-in-out; /* 부드러운 전환 */
        }
    </style>
</head>
<body>
    <!-- 페이드아웃을 위한 오버레이 -->
    <div id="overlay"></div>

    <!-- 
      JavaScript: ES 모듈(import)을 사용합니다.
      three.js 라이브러리 및 필수 애드온들을 CDN에서 불러옵니다.
    -->
    <script type="module">
        // three.js 코어 라이브러리
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        
        // 3D 텍스트 생성을 위한 로더 및 지오메트리
        import { FontLoader } from 'https://unpkg.com/three/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three/examples/jsm/geometries/TextGeometry.js';
        
        // '네온' 효과(블룸)를 위한 포스트 프로세싱
        import { EffectComposer } from 'https://unpkg.com/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- 전역 변수 설정 ---
        let scene, camera, renderer, composer, bloomPass, tunnel, path;
        let font; // 로드된 폰트 저장
        const textObjects = []; // 텍스트 객체들
        const tunnelSegments = 100; // 터널의 길이 (세그먼트 수)
        const segmentLength = 2; // 각 세그먼트의 길이
        const tunnelLength = tunnelSegments * segmentLength;

        let cameraProgress = 0; // 카메라의 터널 내 진행 상태 (0 ~ 1)
        // --- 애니메이션 관련 상수 ---
        const cameraSpeed = 0.15;
        const textRotationSpeed = 0.005;
        let isFadingOut = false; // 페이드아웃 상태 플래그

        // --- 초기화 함수 ---
        // --- 로딩 매니저 설정 ---
        function init() {
            isFadingOut = false; // 초기화 시 플래그 리셋
            cameraProgress = 0; // 진행 상태 초기화
            // 1. Scene (장면) 설정
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 50); // 안개 효과 (가까울수록 잘 보임)

            // 2. Camera (카메라) 설정
            const fov = 75; // 시야각
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 5; // 카메라 초기 위치

            // 3. Renderer (렌더러) 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 조명 (Light) 설정
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // 은은한 전체 조명
            scene.add(ambientLight);

            // 5. 로딩 매니저 설정
            const manager = new THREE.LoadingManager();
            manager.onLoad = () => {
                // 모든 로딩이 완료되면 애니메이션 시작
                console.log('모든 리소스 로딩 완료!');
                animate(); 
            };

            // 5. 터널 생성 (TubeGeometry)
            createTunnel(manager);

            // 6. 포스트 프로세싱 (블룸 효과) 설정
            setupPostProcessing();

            // 7. 3D 텍스트 로드 및 생성
            loadFontAndCreateText(manager);
            
            // 8. 창 크기 조절 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
        }

        // --- 터널 생성 함수 ---
        function createTunnel(manager) {
            // 터널의 경로 (S자 곡선)
            path = new THREE.CatmullRomCurve3( // 전역 변수 path에 할당
                [
                    new THREE.Vector3(0, 0, 10),
                    new THREE.Vector3(10, 5, -tunnelLength * 0.25),
                    new THREE.Vector3(-10, -5, -tunnelLength * 0.75),
                    new THREE.Vector3(0, 0, -tunnelLength)
                ]
            );
            
            // 터널 지오메트리
            const geometry = new THREE.TubeGeometry(
                path,          // 경로
                tunnelSegments, // 터널 세그먼트
                3,             // 터널 반지름
                16,            // 원형 세그먼트
                false          // 닫힘 여부
            );
            
            // 텍스처 로더 생성
            const textureLoader = new THREE.TextureLoader(manager);
            // '회로 기판' 같은 느낌의 텍스처 이미지 로드
            const texture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', (tex) => {
                // 텍스처가 길이를 따라 반복되도록 설정
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                // 텍스처 반복 횟수 설정 (가로 5번, 세로 50번)
                tex.repeat.set(5, 50);
            });

            // 터널 재질 (텍스처 매핑)
            const material = new THREE.MeshBasicMaterial({
                map: texture, // 불러온 텍스처를 재질에 적용
                // wireframe: false, // 텍스처를 보려면 wireframe은 false여야 합니다.
                side: THREE.DoubleSide // 터널 안쪽에서도 보이도록 설정
            });
            
            tunnel = new THREE.Mesh(geometry, material);
            scene.add(tunnel);
        }

        // --- 폰트 로드 및 텍스트 생성 함수 ---
        function loadFontAndCreateText(manager) {
            const fontLoader = new FontLoader(manager);
            // three.js 예제 폰트 (JSON) 사용
            fontLoader.load('https://unpkg.com/three/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
                font = loadedFont;
                
                // 텍스트 재질 (밝은 흰색, 블룸 효과를 받음)
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

                // 텍스트 1: Welcome
                createText("Welcome", textMaterial, -20);
                
                // 텍스트 2: 2025 졸업전시
                createText("2025 졸업전시", textMaterial, -50);
                
                // 텍스트 3: CODE의 세계로...
                createText("CODE의 세계로...", textMaterial, -80);
            });
        }

        // --- 텍스트 생성 헬퍼 함수 ---
        function createText(text, material, zPosition) {
            const textGeo = new TextGeometry(text, {
                font: font,
                size: 1.5,
                height: 0.2,
                curveSegments: 12,
            });
            
            // 텍스트를 중앙에 정렬
            textGeo.center(); 
            
            const textMesh = new THREE.Mesh(textGeo, material);
            textMesh.position.z = zPosition;
            
            scene.add(textMesh);
            textObjects.push(textMesh);
        }

        // --- 포스트 프로세싱 (블룸) 설정 함수 ---
        function setupPostProcessing() {
            // 1. RenderPass: 기본 장면을 렌더링
            const renderPass = new RenderPass(scene, camera);

            // 2. UnrealBloomPass: 블룸(빛 번짐) 효과
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength (강도)
                0.4, // radius (반경)
                0.85 // threshold (밝기 임계값, 이 값보다 밝은 부분만 빛남)
            );
            
            // 3. EffectComposer: 패스들을 조합
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }

        // --- 애니메이션 루프 함수 ---
        function animate() {
            requestAnimationFrame(animate); // 매 프레임마다 animate 함수 호출

            // 페이드아웃이 아닐 때만 카메라와 텍스트를 움직입니다.
            if (!isFadingOut) {
                // 1. 카메라를 터널 경로에 따라 이동
                cameraProgress += 0.0005; // 진행 속도 조절
                if (cameraProgress > 1) cameraProgress = 1;

                // 현재 진행도에 맞는 경로상의 위치를 가져옴
                const newPosition = path.getPointAt(cameraProgress);
                camera.position.copy(newPosition);

                // 카메라가 다음 지점을 바라보도록 설정 (더 자연스러운 움직임)
                const lookAtPosition = path.getPointAt((cameraProgress + 0.01) % 1);
                camera.lookAt(lookAtPosition);

                // 2. 텍스트 회전
                textObjects.forEach(text => {
                    text.rotation.y += textRotationSpeed;
                });

                // 3. 터널의 끝에 도달했을 때 페이드아웃 시작
                if (cameraProgress >= 0.95) { // 경로의 95% 지점에 도달하면 페이드아웃
                    isFadingOut = true;
                    // 화면을 하얗게 덮음 (페이드아웃)
                    document.getElementById('overlay').style.opacity = '1';
                    
                    // (실제 구현 시) 페이드아웃이 완료되면 메인 페이지로 이동
                    setTimeout(() => {
                        window.location.href = 'https://github.com/jang-da/intro./settings/pages'; // 여기에 실제 메인 페이지 파일명이나 주소를 입력하세요.
                    }, 1000); // 1초(페이드아웃 시간) 후에 페이지 이동
                }
            }

            // 4. 렌더링은 매 프레임 수행합니다.
            composer.render(); // <- 이것 사용
        }

        // --- 창 크기 조절 함수 ---
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 카메라 비율 업데이트
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // 렌더러 및 컴포저 크기 업데이트
            renderer.setSize(width, height);
            composer.setSize(width, height);
        }

        // --- 실행 ---
        init();
    </script>
</body>
</html>